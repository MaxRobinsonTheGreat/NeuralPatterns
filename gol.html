
<div id="canvasContainer">
    <canvas id="renderCanvas" width="1024" height="1024"></canvas>
</div>

<style>
*{
	border: none;
	margin: 0px;
	padding: 0px;
	box-sizing: border-box;
}

html, body{
	height: 100%;
	width: 100%;
}

body{
	overflow: hidden;
}

#canvasContainer{
	position: absolute;
	/* height: 100%; */

}

#renderCanvas{
	/* height: 1024px;
	width: 2048px; */
	height: 100%;

	background-color: #000000;

	/* image-rendering: optimizeSpeed;              */
	/* image-rendering: -moz-crisp-edges;           */
	/* image-rendering: -webkit-optimize-contrast;  */
	/* image-rendering: -o-crisp-edges;             */
	/* image-rendering: pixelated;                  */
	/* -ms-interpolation-mode: nearest-neighbor;   IE */
}
</style>


<script  id="fragment-shader-2d" type="x-shader/x-fragment">
	#define PI 3.1415926538

    precision mediump float;

    uniform sampler2D u_image;

    varying vec2 texCoord;

    uniform vec2 onePixel;

    uniform bool doStep;

	uniform vec4 colorMask;

	uniform float u_kernel[9];


    vec2 getCoords(vec2 coord, vec2 offset){
        //return vec2(mod(coord.x + onePixel.x * offset.x, 1.0), mod(coord.y + onePixel.y * offset.y, 1.0));
        return mod(coord + onePixel * offset, 1.0);
    }

    float activation(float x) {
		// input is in range [min(0, sum(negative values)), max(0, sum(positive values))]
        return x;
        //return sin(x - PI/2.);//sin(x) + cos(x) + sin(2.*x) + cos(2.*x) + sin(3.*x) + cos(3.*x) + sin(4.*x) + cos(5.*x);
		//return abs(x);
        //return max(x,0.); // relu
        //return 1.0/(4.0*abs(x-3.18)+1.0); // inverse
		//return abs(x);
		// game of life
		//if (x == 3. || x == 11. || x == 12.){
		//	return 1.0;
		//}
		//return 0.;
		//return sin(x);
		// rule 30;
		//if (x == 1. || x == 2. || x == 3.|| x == 4.){
		//	return 1.0;
		//}
		//return 0.;

		//return x;
		//if (x > 10.) {
		//	return 1.;
		//}
		//return log(sin(x - 1.85)) + 1.;

		//return sin(1./x);
		//return (exp(2.*x)-1.)/(exp(2.*x)+1.); //tanh
		//return (-1./(x+1.)) + 1.; // similar tanh?

        //return x;
        //return 1./pow(2., (pow(x-4.5, 2.))); // gaussian
        //return (exp(x)-exp(-x))/(exp(x)+exp(-x));
        //return 1./(1. + exp(-x+3.5)); // sigmoid
		//return (-pow(2.*x-2.5, 2.)+1.); // power hill

        //if (x==0.)
        //    return 0.;
        //return sin(1./x);

		// returned value will be clipped between [0,1]
    }

    void main(void){

        if(doStep){
            float sum = texture2D(u_image, getCoords(texCoord, vec2(1.0, -1.0))).r * u_kernel[0]
                + texture2D(u_image, getCoords(texCoord, vec2(0.0, -1.0))).r * u_kernel[1]
                + texture2D(u_image, getCoords(texCoord, vec2(-1.0, -1.0))).r * u_kernel[2]
                + texture2D(u_image, getCoords(texCoord, vec2(1.0, 0.0))).r * u_kernel[3]
                + texture2D(u_image, getCoords(texCoord, vec2(0.0, 0.0))).r * u_kernel[4]
                + texture2D(u_image, getCoords(texCoord, vec2(-1.0, 0.0))).r * u_kernel[5]
                + texture2D(u_image, getCoords(texCoord, vec2(1.0, 1.0))).r * u_kernel[6]
                + texture2D(u_image, getCoords(texCoord, vec2(0.0, 1.0))).r * u_kernel[7]
                + texture2D(u_image, getCoords(texCoord, vec2(-1.0, 1.0))).r * u_kernel[8];
            
            float x = activation(sum);

			//x += texture2D(u_image, getCoords(texCoord, vec2(0.0, 0.0))).r; // cumulative display
            gl_FragColor = vec4(x, x, x, x);

        } else {
			// 250, 158, 255
			// color masking
			gl_FragColor = texture2D(u_image, texCoord).rgba * colorMask;
            
        }
    }
</script>

<script  id="vertex-shader-2d" type="x-shader/x-vertex">
    attribute vec2 coordinates;

    varying vec2 texCoord;
    
    void main(void){
        
        texCoord = (coordinates/2.0 + 0.5);
        
        gl_Position = vec4(coordinates, 1.0, 1.0);
    
    }
</script>

<script>

// accordion settings menu
// About 
// Start State - dropdown (center, random, random boolean, image upload), edges dropdown
// Update Rule - filter (randomize button, random range), activation function, dropdown()
// Display - color, culumative, wrap


class Renderer {
	constructor(canvas) {
		this.gl = canvas.getContext("webgl");
		this.height = canvas.height;
		this.width = canvas.width;
	}

	compileShaders(vertexShaderProgram, fragShaderProgram) {
		let gl = this.gl;

		// Create a vertex shader object
		let vertShader = gl.createShader(gl.VERTEX_SHADER);

		// Attach vertex shader source code
		gl.shaderSource(vertShader, vertexShaderProgram);

		// Compile the vertex shader
		gl.compileShader(vertShader);

		// Create fragment shader object
		let fragShader = gl.createShader(gl.FRAGMENT_SHADER);

		// Attach fragment shader source code
		gl.shaderSource(fragShader, fragShaderProgram);

		// Compile the fragmentt shader
		gl.compileShader(fragShader);

		// Create a shader program object to store
		// the combined shader program
		let shaderProgram = gl.createProgram();
		this.shader = shaderProgram;

		// Attach a vertex shader
		gl.attachShader(shaderProgram, vertShader); 

		// Attach a fragment shader
		gl.attachShader(shaderProgram, fragShader);

		// Link both programs
		gl.linkProgram(shaderProgram);

		// Use the combined shader program object
		gl.useProgram(shaderProgram);

		if(gl.getShaderInfoLog(vertShader)){
			console.warn(gl.getShaderInfoLog(vertShader));
		}
		if(gl.getShaderInfoLog(fragShader)){
			console.warn(gl.getShaderInfoLog(fragShader));
		}
		if(gl.getProgramInfoLog(shaderProgram)){
			console.warn(gl.getProgramInfoLog(shaderProgram));
		}
		let vertexBuffer = gl.createBuffer();

		/*==========Defining and storing the geometry=======*/

		let vertices = [
			-1.0, -1.0,
			1.0, -1.0,
			-1.0,  1.0,
			-1.0,  1.0,
			1.0, -1.0,
			1.0,  1.0
		];

		this.size = ~~(vertices.length/2);
		
		gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		gl.bindBuffer(gl.ARRAY_BUFFER, null);

		gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

		// Get the attribute location
		let coord = gl.getAttribLocation(shaderProgram, "coordinates");

		// Point an attribute to the currently bound VBO
		gl.vertexAttribPointer(coord, 2, gl.FLOAT, false, 0, 0);

		// Enable the attribute
		gl.enableVertexAttribArray(coord);
		
		this.onePixelAttr = gl.getUniformLocation(shaderProgram, "onePixel");
		this.doStepAttr = gl.getUniformLocation(shaderProgram, "doStep");
	}

	setState(startState) {
		let gl = this.gl;
		
		this.stateTexture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this.stateTexture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, startState);

		this.txa = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this.txa);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
		
		this.fba = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.fba);
		
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.txa, 0);
		
		this.txb = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this.txb);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
		
		this.fbb = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbb);
		
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.txb, 0);

		gl.bindTexture(gl.TEXTURE_2D, this.stateTexture);
	}

	getState() {
		let gl = this.gl;
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbb);
		let data = new Uint8Array(this.width * this.height * 4);
		gl.readPixels(0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, data);
		return data;
	}

	setColor(rgb) {
		let gl = this.gl;
		this.colorMask = {r:rgb[0], g:rgb[1], b:rgb[2]};
		
		this.colorMaskLocation = gl.getUniformLocation(this.shader, "colorMask");
		
		// let channel = -1;
		// for (let i in rgb) {
		// 	if (rgb[i] === 1){
		// 		channel = i;
		// 		break;
		// 	}
		// }
		// if (channel === -1){
		// 	console.error("RGB must have one full 1.0 value");
		// 	return false;
		// }
		// return true;
	}

	setKernel(kernel) {
		this.kernelLocation = this.gl.getUniformLocation(this.shader, "u_kernel[0]");
		this.kernel = kernel;
	}

	beginRender(){
		let gl = this.gl;
		this.running = true;

		gl.uniform2f(this.onePixelAttr, 1/this.width, 1/this.height);
		gl.uniform1f(this.doStepAttr, true);
        gl.uniform1fv(this.kernelLocation, this.kernel);
		gl.uniform4f(this.colorMaskLocation, this.colorMask.r, this.colorMask.g, this.colorMask.b, 1.0);

		// gl.bindTexture(gl.TEXTURE_2D, this.stateTexture);

		this.render();
		
	}

	stopRender(){
		this.running = false;
		if (this.updaterequest)
			window.cancelAnimationFrame(this.updaterequest);
	}

	render(){
		let gl = this.gl;
		{
			// first apply the update rule
			gl.uniform1f(this.doStepAttr, true);

			gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbb);
			gl.drawArrays(gl.TRIANGLES, 0, this.size);
			gl.bindTexture(gl.TEXTURE_2D, this.txb); // use texture b

			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.drawArrays(gl.TRIANGLES, 0, this.size);

			gl.uniform1f(this.doStepAttr, false);
		}
		{
			// then apply the color masking
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.fba);
			gl.drawArrays(gl.TRIANGLES, 0, this.size);
			gl.bindTexture(gl.TEXTURE_2D, this.txa); // use texture a
			
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.drawArrays(gl.TRIANGLES, 0, this.size);
		}

		if(this.running){
			this.updaterequest = window.requestAnimationFrame(()=>{this.render();});
			// setTimeout(()=>{this.renderInternally(!mode);}, 0); // set render speed
		}
	}
}

function generateState(height, width, option='random') {
	let cells = new Uint8Array(height * width * 4);
	switch(option) {
		case 'random':
			for(let i = 0; i < cells.length; i++){
				cells[i] = Math.floor(255 * Math.random())
			}
			cells[height * width * 2 + width*2] = 255;
			break;

		case 'random_bool':
			for(let i = 0; i < cells.length; i++){
				cells[i] = 255 * Math.floor(Math.random()*2);
			}
			break;

		case 'center': 
			for(let i = 0; i < cells.length; i++){
				cells[i] = 0;
			}
			cells[height * width * 2 + width*2] = 255;
			break;
		
		case 'center_top':
			for(let i = 0; i < cells.length; i++){
				cells[i] = 0;
			}
			cells[width*2] = 255;
			break;
	}
	return cells;
}

function generateRandomKernel(min=-1, max=1) {
	let range = max - min;
	let kernel = [];
	for (let i=0; i<9; i++){
		kernel[i] = Math.random()*range + min;
	}
	return kernel;
}

const fragmentShader = document.getElementById('fragment-shader-2d').text;
const vertexShader = document.getElementById('vertex-shader-2d').text;

let canvas = document.getElementById("renderCanvas");

let width = canvas.width;
let height = canvas.height;

let cells = generateState(height, width, 'random');
let renderer = new Renderer(canvas);
renderer.compileShaders(vertexShader, fragmentShader);
renderer.setState(cells);
renderer.setColor([1.0, 0.5, 0.5]);
renderer.setKernel(generateRandomKernel(-10, 10));
// renderer.setKernel(
// 	[0, 0, 0,
//      0, 0, 0,
// 	 1, 2, 4]
// )
renderer.beginRender();

document.body.onkeyup = function(e){
    if(e.keyCode == 32){
		renderer.stopRender();
        renderer.setKernel(generateRandomKernel());
		renderer.beginRender();
	}
}

</script>